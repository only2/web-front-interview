<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    什么是执行上下文？
    简而言之，执行上下文是评估和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。
        JavaScript 中有三种执行上下文类型。

        全局执行上下文 — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
        函数执行上下文 — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
        Eval 函数执行上下文 — 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它。

    执行栈
        执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。
        当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。
        引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。
    
    怎么创建执行上下文？
    到现在，我们已经看过 JavaScript 怎样管理执行上下文了，现在让我们了解 JavaScript 引擎是怎样创建执行上下文的。
        创建执行上下文有两个阶段：1) 创建阶段 和 2) 执行阶段。
        在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：
            this 值的决定，即我们所熟知的 This 绑定。
                在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用 Window 对象)。
                在函数执行上下文中，this 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined（在严格模式下）
            创建词法环境组件。
                词法环境，其实就是作用域，是一套约定好的规则。我们写代码，应该按照这个规则来。JS引擎对JS源码进行词法分析，也是按照这个规则来。
                在JavaScript中，我们可以将作用域定义为一套规则，这套规则用来管理JS引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

                作用域链
                    首先我们要明确的一点是，作用域和作用域链是不同的。
                    作用域是一套规则。
                    而作用域链，则是作用域的具体实现。
                    作用域链，是由当前执行环境与上层上下文环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。
            创建变量环境组件。
                其实也就是指变量对象的创建，依次经历了以下几个过程。
                    一、建立arguments对象：检查当前上下文中的参数，建立该对象下的属性与
                    属性值。
                    二、检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用
                    三、检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined，const/let 声明的变量没有赋值，不能提前使用
                    tip: 如果 var 变量与函数同名，则在这个阶段，以函数值为准，在下一个阶段，函数值会被变量值覆盖
            ExecutionContext = {
                ThisBinding = <this value>,
                LexicalEnvironment = { ... },
                VariableEnvironment = { ... },
            }
            在执行一段代码时，JS 引擎会首先创建一个执行栈然后JS引擎会创建一个全局执行上下文，并 push到执行栈中, 这个过程JS引擎会为这段代码中所有变量分配内存并赋一个初始值 (undefined)，在创建完成后，JS引擎会进入执行阶段，这个过程JS引擎会逐行的执行代码，即 为之前分配好内存的变量逐个赋值(真实值)。
            如果这段代码中存在function的声明和调用，那么JS引擎会创建一个函数执行上下文，并push到 执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函 数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也 是为什么子函数能够访问到父函数内所声明的变量。
            还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将 父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭 包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用 这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。
            最后，JS引擎是单线程的，那么它是如何处理高并发的呢?即当代码中存在异步调用时JS是如何执 行的。比如setTimeout或fetch请求都是non-blocking的，当异步调用代码触发时，JS引擎会将需 要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push 进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务 队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为事件循环。

</body>
    <script>
        let a = 'Hello World!';
        function first() {
        console.log('Inside first function');
        second();
        console.log('Again inside first function');
        }

        function second() {
        console.log('Inside second function');
        }

        first();
        console.log('Inside Global Execution Context');
        // 当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 first() 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。
        // 当从 first() 函数内部调用 second() 函数时，JavaScript 引擎为 second() 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 second() 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 first() 函数的执行上下文。
        // 当 first() 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。
    </script>
</html>