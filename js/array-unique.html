<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    数组去重
</body>
    <script>
        // 双重循环去重
        Array.prototype.unique = function () {
            const newArray = [];
            let isRepeat;
            for (let i = 0; i < this.length; i++) {
                isRepeat = false;
                for (let j = 0; j < newArray.length; j++) {
                if (this[i] === newArray[j]) {
                    isRepeat = true;
                    break;
                }
                }
                if (!isRepeat) {
                newArray.push(this[i]);
                }
            }
            return newArray;
        }
        // Array.prototype.indexOf()
        // 基本思路：如果索引不是第一个索引，说明是重复值。
        Array.prototype.unique = function () {
            return this.filter((item, index) => {
                return this.indexOf(item) === index;
            })
        }
        let arr = [1, 2, 3, 22, 233, 22, 2, 233, 'a', 3, 'b', 'a'];
        Array.prototype.unique = function () {
        const newArray = [];
        this.forEach(item => {
            if (newArray.indexOf(item) === -1) {
                newArray.push(item);
            }
        });
        return newArray;
        }
        //Array.prototype.sort()
        // 先对原数组进行排序，然后再进行元素比较。
        Array.prototype.unique = function () {
            const newArray = [];
            this.sort();
            for (let i = 0; i < this.length; i++) {
                if (this[i] !== this[i + 1]) {
                newArray.push(this[i]);
                }
            }
            return newArray;
        }
        // Array.prototype.includes()
        Array.prototype.unique = function () {
            const newArray = [];
            this.forEach(item => {
                if (!newArray.includes(item)) {
                    newArray.push(item);
                }
            });
            return newArray;
        }
        // Map
        Array.prototype.unique = function () {
            const newArray = [];
            const tmp = new Map();
            for(let i = 0; i < this.length; i++){
                    if(!tmp.get(this[i])){
                        tmp.set(this[i], 1);
                        newArray.push(this[i]);
                    }
                }
            return newArray;
        }
        Array.prototype.unique = function () {
            const tmp = new Map();
            return this.filter(item => {
                return !tmp.has(item) && tmp.set(item, 1);
            })
        }
        // Set
        Array.prototype.unique = function () {
            const set = new Set(this);
            return Array.from(set);
        }
        Array.prototype.unique = function () {
            return [...new Set(this)];
        }
        //总结
        //除了考虑时间复杂度外、性能之外，还要考虑数组元素的数据类型（例如下面的例子）等问题权衡选择出采用哪种算法，例如：
        const arr = [1, 1, '1', '1', 0, 0, '0', '0', undefined, undefined, null, null, NaN, NaN, {}, {}, [], [], /a/, /a/];
        //经过综合考虑，最优的数组去重算法是采用Map数据结构实现的算法。
    </script>
</html>